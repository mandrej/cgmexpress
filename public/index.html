<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SIBIONICS CGM</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/jszip.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/xlsx.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <h3 style="margin-left: 10px">SIBIONICS CGM</h3>
    <div class="row">
      <div id="date-filter"></div>
      <div id="main-chart"></div>
    </div>
    <div class="row">
      <div id="time-brush"></div>
    </div>
    <div id="drop-zone">Drag and drop files here</div>

    <script>
      const datetime = 'Vreme';
      const value = 'OÄitavanje senzora(mmol/L)';

      const parseDate = d3.timeParse('%d-%m-%Y %H:%M');
      const parseTime = d3.timeParse('%H:%M');
      const formatDate = d3.timeFormat('%Y-%m-%d');
      const formatTime = d3.timeFormat('%H:%M');
      // american style label for main-chart
      const parseDateLabel = d3.timeParse('%Y-%m-%d');
      const formatDateLabel = d3.timeFormat('%a, %b %d, %Y');

      const dropZone = document.getElementById('drop-zone');
      dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.stopPropagation();
      });

      dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        event.stopPropagation();
        // File handling logic will go here
        const files = event.dataTransfer.files;
        const file = files[0];

        console.log('Dropped file type:', file.type);
        parseExcel(file)
          .then((original) => {
            parseOriginal(original);
          })
          .catch((error) => {
            console.error('Error parsing Excel:', error);
          });
      });

      const parseExcel = function (file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            try {
              var data = e.target.result;
              var workbook = XLSX.read(data, {
                type: 'binary',
              });

              workbook.SheetNames.forEach(function (sheetName) {
                const XL_row_object = XLSX.utils.sheet_to_row_object_array(
                  workbook.Sheets[sheetName]
                );
                resolve(XL_row_object);
              });
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = function (ex) {
            reject(ex);
          };

          reader.readAsBinaryString(file);
        });
      };

      const parseOriginal = function (original) {
        const data = original.map((d) => {
          const [datePart, timePart, _] = d[datetime].split(' ');
          const dateObj = parseDate(datePart + ' ' + timePart);
          return {
            date: formatDate(dateObj),
            dateObj: dateObj,
            time: formatTime(dateObj),
            timeObj: parseTime(timePart),
            value: +d[value].replace(',', '.'),
          };
        });
        // console.log(data);s
        drawChart(data);
      };

      d3.json('/data').then((original) => {
        original.shift(); // remove first element

        const data = original.map((d) => {
          const [datePart, timePart, _] = d.datetime.split(' ');
          const dateObj = parseDate(datePart + ' ' + timePart);
          return {
            date: formatDate(dateObj),
            dateObj: dateObj,
            time: formatTime(dateObj),
            timeObj: parseTime(timePart),
            value: +d.value.replace(',', '.'),
          };
        });
        drawChart(data);
      });

      let selectedDates = new Set();
      let timeRange = null;

      const drawChart = (originalData) => {
        const data = [...originalData]; // copy
        const uniqueDates = [...new Set(data.map((d) => d.date))].sort();
        const colorScale = d3
          .scaleOrdinal(d3.schemeCategory10)
          .domain(uniqueDates);

        // Initially select all dates
        selectedDates = new Set(uniqueDates);

        const filterData = () => {
          return data.filter(d => selectedDates.has(d.date) &&
            (!timeRange || (d.timeObj >= timeRange[0] && d.timeObj <= timeRange[1])));
        };

        const updateCharts = () => {
          const filteredData = filterData();
          drawDateFilter(uniqueDates);
          drawTimeBrush(filteredData);
          drawMainChart(filteredData);
        };

        const drawDateFilter = (dates) => {
          const container = d3.select('#date-filter');
          container.selectAll('*').remove();

          const items = container.selectAll('.date-item')
            .data(dates)
            .enter().append('div')
            .attr('class', 'date-item')
            .style('cursor', 'pointer')
            .style('padding', '5px')
            .style('background-color', d => selectedDates.has(d) ? colorScale(d) : '#f0f0f0')
            .style('color', d => selectedDates.has(d) ? 'white' : 'black')
            .style('margin-bottom', '2px')
            .style('font-size', '12px')
            .text(d => formatDateLabel(parseDateLabel(d)))
            .on('click', function(event, d) {
              if (selectedDates.has(d)) {
                selectedDates.delete(d);
              } else {
                selectedDates.add(d);
              }
              updateCharts();
            });
        };

        const drawTimeBrush = (filteredData) => {
          const container = d3.select('#time-brush');
          container.selectAll('*').remove();

          const margin = { top: 10, right: 0, bottom: 20, left: 0 };
          const width = 1060 - margin.left - margin.right;
          const height = 100 - margin.top - margin.bottom;

          const svg = container.append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom + 20)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

          const x = d3.scaleTime()
            .domain(d3.extent(filteredData, d => d.timeObj))
            .range([0, width]);

          const y = d3.scaleLinear()
            .domain([0, d3.max(filteredData, d => d.value)])
            .range([height, 0]);

          // Group data by hour
          const hourData = d3.rollup(filteredData,
            v => d3.mean(v, d => d.value),
            d => d3.timeHour.floor(d.timeObj)
          );

          const bars = svg.selectAll('.bar')
            .data(Array.from(hourData, ([key, value]) => ({ time: key, value })))
            .enter().append('rect')
            .attr('class', 'bar')
            .attr('x', d => x(d.time))
            .attr('y', d => y(d.value))
            .attr('width', width / hourData.size)
            .attr('height', d => height - y(d.value))
            .attr('fill', 'steelblue');

          svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).ticks(d3.timeHour.every(1)));

          const brush = d3.brushX()
            .extent([[0, 0], [width, height]])
            .on('brush end', (event) => {
              if (event.selection) {
                // Snap to 30-minute intervals
                const snappedStart = d3.timeMinute.every(30).floor(x.invert(event.selection[0]));
                const snappedEnd = d3.timeMinute.every(30).ceil(x.invert(event.selection[1]));
                timeRange = [snappedStart, snappedEnd];

                // Update brush selection to snapped position
                d3.select(event.sourceEvent.target)
                  .transition()
                  .call(brush.move, [x(snappedStart), x(snappedEnd)]);
              } else {
                timeRange = null;
              }
              updateCharts();
            });

          svg.append('g')
            .attr('class', 'brush')
            .call(brush);

          // Add time range display
          const timeRangeText = svg.append('text')
            .attr('class', 'time-range-text')
            .attr('x', 0)
            .attr('y', height + 35)
            .attr('font-size', '12px')
            .attr('fill', '#333');

          function updateTimeRangeDisplay() {
            if (timeRange) {
              const startTime = formatTime(timeRange[0]);
              const endTime = formatTime(timeRange[1]);
              timeRangeText.text(`Time Range: ${startTime} - ${endTime}`);
            } else {
              const startTime = formatTime(d3.min(filteredData, d => d.timeObj));
              const endTime = formatTime(d3.max(filteredData, d => d.timeObj));
              timeRangeText.text(`Time Range: ${startTime} - ${endTime} (All)`);
            }
          }

          updateTimeRangeDisplay();
        };

        const drawMainChart = (filteredData) => {
          const container = d3.select('#main-chart');
          container.selectAll('*').remove();

          const margin = { top: 5, right: 50, bottom: 15, left: 50 };
          const width = 1000 - margin.left - margin.right;
          const height = 400 - margin.top - margin.bottom;

          const svg = container.append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

          const x = d3.scaleTime()
            .domain(timeRange || d3.extent(filteredData, d => d.timeObj))
            .range([0, width]);

          const y = d3.scaleLinear()
            .domain(d3.extent(filteredData, d => d.value))
            .nice()
            .range([height, 0]);

          // Group data by date
          const dateData = d3.group(filteredData, d => d.date);

          const line = d3.line()
            .x(d => x(d.timeObj))
            .y(d => y(d.value))
            .curve(d3.curveMonotoneX);

          svg.selectAll('.line')
            .data(Array.from(dateData, ([date, values]) => ({ date, values: values.sort((a, b) => a.timeObj - b.timeObj) })))
            .enter().append('path')
            .attr('class', 'line')
            .attr('d', d => line(d.values))
            .attr('stroke', d => colorScale(d.date))
            .attr('stroke-width', 2)
            .attr('fill', 'none');

          svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x));

          svg.append('g')
            .call(d3.axisLeft(y));

          // Grid lines
          svg.append('g')
            .attr('class', 'grid')
            .attr('opacity', 0.3)
            .call(d3.axisBottom(x).tickSize(height).tickFormat(''));

          svg.append('g')
            .attr('class', 'grid')
            .attr('opacity', 0.3)
            .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));

          // Add click label
          const clickLabel = svg.append('text')
            .attr('class', 'click-label')
            .attr('x', 10)
            .attr('y', 20)
            .attr('font-size', '12px')
            .attr('fill', '#333')
            .style('pointer-events', 'none')
            .text('');

          // Add invisible overlay for click detection
          svg.append('rect')
            .attr('class', 'click-overlay')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', width)
            .attr('height', height)
            .style('fill', 'none')
            .style('pointer-events', 'all')
            .on('click', function(event) {
              const [mouseX, mouseY] = d3.pointer(event);
              const timeClicked = x.invert(mouseX);
              const valueClicked = y.invert(mouseY);

              // Find closest data point
              let closestPoint = null;
              let minDistance = Infinity;

              for (const [date, values] of dateData) {
                for (const point of values) {
                  const distance = Math.sqrt(
                    Math.pow(x(point.timeObj) - mouseX, 2) +
                    Math.pow(y(point.value) - mouseY, 2)
                  );
                  if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = point;
                  }
                }
              }

              if (closestPoint && minDistance < 50) { // Only show if close enough
                clickLabel
                  .attr('x', x(closestPoint.timeObj) + 5)
                  .attr('y', y(closestPoint.value) - 5)
                  .text(`${formatTime(closestPoint.timeObj)}: ${closestPoint.value} mmol/L`)
                  .style('visibility', 'visible');
              } else {
                clickLabel.style('visibility', 'hidden');
              }
            });
        };

        updateCharts();
      };
    </script>
  </body>
</html>
