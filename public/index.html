<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SIBIONICS CGM</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/crossfilter2@1.5.4/crossfilter.min.js"></script>
    <script src="https://unpkg.com/dc@4.2.7/dist/dc.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/jszip.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/xlsx.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/dc@4.2.7/dist/style/dc.min.css"
    />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <h1>SIBIONICS CGM</h1>
      <div class="dashboard-grid">
        <!-- Date Filter Sidebar -->
        <div id="date-filter-container" class="chart-container">
          <div class="chart-title">Date Filter</div>
          <div id="date-filter"></div>
        </div>

        <!-- Main Chart -->
        <div id="main-chart-container" class="chart-container">
          <div class="chart-title">Glucose Readings</div>
          <div id="main-chart"></div>
        </div>

        <!-- Controls (Drop Zone) -->
        <div id="controls-container" class="chart-container">
          <div class="chart-title">Upload Data</div>
          <div id="drop-zone">Drag and drop files here</div>
        </div>

        <!-- Time Brush -->
        <div id="time-brush-container" class="chart-container">
          <div class="chart-title">Time Filter</div>
          <div id="time-brush"></div>
        </div>
      </div>
    </div>

    <script>
      const datetime = 'Vreme';
      const value = 'OÄitavanje senzora(mmol/L)';

      const parseDate = d3.timeParse('%d-%m-%Y %H:%M');
      const parseTime = d3.timeParse('%H:%M');
      const formatDate = d3.timeFormat('%Y-%m-%d');
      const formatTime = d3.timeFormat('%H:%M');
      // american style label for main-chart
      const parseDateLabel = d3.timeParse('%Y-%m-%d');
      const formatDateLabel = d3.timeFormat('%a, %b %d, %Y');

      const dropZone = document.getElementById('drop-zone');

      dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.stopPropagation();
        dropZone.classList.add('dragover');
      });

      dropZone.addEventListener('dragleave', (event) => {
        event.preventDefault();
        event.stopPropagation();
        dropZone.classList.remove('dragover');
      });

      dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        event.stopPropagation();
        dropZone.classList.remove('dragover');

        // File handling logic will go here
        const files = event.dataTransfer.files;
        const file = files[0];

        console.log('Dropped file type:', file.type);
        parseExcel(file)
          .then((original) => {
            parseOriginal(original);
          })
          .catch((error) => {
            console.error('Error parsing Excel:', error);
          });
      });

      // Window resize handler for responsive charts
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          dc.renderAll();
        }, 250);
      });

      const parseExcel = function (file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            try {
              var data = e.target.result;
              var workbook = XLSX.read(data, {
                type: 'binary',
              });

              workbook.SheetNames.forEach(function (sheetName) {
                const XL_row_object = XLSX.utils.sheet_to_row_object_array(
                  workbook.Sheets[sheetName]
                );
                resolve(XL_row_object);
              });
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = function (ex) {
            reject(ex);
          };

          reader.readAsBinaryString(file);
        });
      };

      const parseOriginal = function (original) {
        const data = original.map((d) => {
          const [datePart, timePart, _] = d[datetime].split(' ');
          const dateObj = parseDate(datePart + ' ' + timePart);
          return {
            date: formatDate(dateObj),
            dateObj: dateObj,
            time: formatTime(dateObj),
            timeObj: parseTime(timePart),
            value: +d[value].replace(',', '.'),
          };
        });
        // console.log(data);s
        drawChart(data);
      };

      // d3.json('/data').then((original) => {
      //   original.shift(); // remove first element

      //   const data = original.map((d) => {
      //     const [datePart, timePart, _] = d.datetime.split(' ');
      //     const dateObj = parseDate(datePart + ' ' + timePart);
      //     return {
      //       date: formatDate(dateObj),
      //       dateObj: dateObj,
      //       time: formatTime(dateObj),
      //       timeObj: parseTime(timePart),
      //       value: +d.value.replace(',', '.'),
      //     };
      //   });
      //   drawChart(data);
      // });

      const drawChart = (data) => {
        const uniqueDates = [...new Set(data.map((d) => d.date))];
        const colorScale = d3
          .scaleOrdinal(d3.schemeCategory10)
          .domain(uniqueDates);

        const ndx = crossfilter(data);

        // Get container dimensions for responsive sizing
        const dateFilterContainer = document.getElementById(
          'date-filter-container'
        );
        const mainChartContainer = document.getElementById(
          'main-chart-container'
        );
        const timeBrushContainer = document.getElementById(
          'time-brush-container'
        );

        const dateFilterWidth = dateFilterContainer.clientWidth - 40; // subtract padding
        const mainChartWidth = mainChartContainer.clientWidth - 40;
        const timeBrushWidth = timeBrushContainer.clientWidth - 40;

        // --- Define date filter chart ---
        const dateDim = ndx.dimension((d) => d.date);
        const dateGroup = dateDim.group();

        const dateFilter = new dc.RowChart('#date-filter');
        dateFilter
          .width(dateFilterWidth)
          .height(400)
          .margins({ top: 20, left: 10, right: 10, bottom: 30 })
          .dimension(dateDim)
          .group(dateGroup)
          .label((d) => formatDateLabel(parseDateLabel(d.key)))
          .ordering((d) => d.key)
          .colors(colorScale)
          .elasticX(true)
          .xAxis()
          .ticks(4);

        // --- Define time brush chart ---
        const timeBrush = new dc.BarChart('#time-brush');
        const timeDim = ndx.dimension((d) => d.timeObj);
        const timeGroup = timeDim.group();

        timeBrush
          .width(timeBrushWidth)
          .height(100)
          .margins({ top: 10, right: 50, bottom: 20, left: 40 })
          .dimension(timeDim)
          .group(timeGroup)
          .x(
            d3
              .scaleTime()
              .domain([
                d3.min(data, (d) => d.timeObj),
                d3.max(data, (d) => d.timeObj),
              ])
          )
          .xUnits(d3.timeHour)
          .brushOn(true)
          .elasticY(true)
          .xAxis()
          .ticks(d3.timeHour.every(1));

        // --- Define main chart ---
        const seriesDim = ndx.dimension((d) => [d.date, d.timeObj]);
        const valueGroup = seriesDim.group().reduceSum((d) => d.value);

        const mainChart = new dc.SeriesChart('#main-chart');
        const minTime = d3.min(data, (d) => d.timeObj);
        const maxTime = d3.max(data, (d) => d.timeObj);

        mainChart
          .width(mainChartWidth)
          .height(400)
          .margins({ top: 20, right: 50, bottom: 40, left: 50 })
          .chart((subChart) =>
            new dc.LineChart(subChart)
              .curve(d3.curveMonotoneX)
              .renderArea(false)
              .renderDataPoints(false)
              .label((d) => d.value)
          )
          .title((d) => `${formatTime(d.key[1])}: ${d.value}`)
          .x(d3.scaleTime().domain([minTime, maxTime]))
          .elasticY(true)
          .brushOn(false)
          .renderHorizontalGridLines(true)
          .renderVerticalGridLines(true)
          .dimension(seriesDim)
          .group(valueGroup)
          .seriesAccessor((d) => d.key[0]) // each date = series
          .keyAccessor((d) => d.key[1]) // time = x
          .valueAccessor((d) => d.value) // value = y
          .colors(colorScale);
        // .legend(dc.legend().x(70).y(10).itemHeight(13).gap(5));

        // Update main chart domain based on time brush selection
        timeBrush.on('filtered', function (chart, filter) {
          if (filter) {
            mainChart.x().domain(filter);
          } else {
            mainChart.x().domain([minTime, maxTime]);
          }
          dc.redrawAll();
        });

        // Add preRedraw hook to dynamically adjust y-axis based on filtered data
        const updateYAxis = function (chart) {
          const filteredData = seriesDim.top(Infinity);

          if (filteredData.length > 0) {
            const values = filteredData.map((d) => d.value);
            const minValue = d3.min(values);
            const maxValue = d3.max(values);

            // Add 5% padding to the range for better visualization
            const padding = (maxValue - minValue) * 0.05;
            const yMin = Math.max(0, minValue - padding);
            const yMax = maxValue + padding;

            // Check if y-scale exists, if not create it
            if (!chart.y()) {
              chart.y(d3.scaleLinear());
            }
            chart.y().domain([yMin, yMax]);
          }
        };

        mainChart.on('preRender', updateYAxis);
        mainChart.on('preRedraw', updateYAxis);

        // Also trigger on date filter changes
        dateFilter.on('filtered', function () {
          dc.redrawAll();
        });

        dc.renderAll();
      };
    </script>
  </body>
</html>
