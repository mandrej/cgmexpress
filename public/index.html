<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SIBIONICS CGM</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/jszip.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/xlsx.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div id="dashboard">
      <h3>SIBIONICS CGM</h3>
      <div class="row primary">
        <div id="date-filter"></div>
        <svg id="main-chart"></svg>
      </div>
      <div class="row secondary">
        <div id="time-brush"></div>
      </div>
      <div id="drop-zone">Drag and drop files here</div>
    </div>

    <script>
      const datetime = 'Vreme';
      const value = 'Očitavanje senzora(mmol/L)';

      const parseDate = d3.timeParse('%d-%m-%Y %H:%M');
      const parseTime = d3.timeParse('%H:%M');
      const formatDate = d3.timeFormat('%Y-%m-%d');
      const formatTime = d3.timeFormat('%H:%M');
      // american style label for main-chart
      const parseDateLabel = d3.timeParse('%Y-%m-%d');
      const formatDateLabel = d3.timeFormat('%a, %b %d, %Y');

      const minuteStep = 30;
      const snapInterval = d3.timeMinute.every(minuteStep) || d3.timeMinute;
      const getDefaultTimeRange = () => [
        parseTime('00:00'),
        parseTime('23:59'),
      ];
      const dropZone = document.getElementById('drop-zone');
      dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.stopPropagation();
      });

      dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        event.stopPropagation();
        // File handling logic will go here
        const files = event.dataTransfer.files;
        const file = files[0];

        console.log('Dropped file type:', file.type);
        parseExcel(file)
          .then((original) => {
            parseOriginal(original);
          })
          .catch((error) => {
            console.error('Error parsing Excel:', error);
          });
      });

      const parseExcel = function (file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            try {
              var data = e.target.result;
              var workbook = XLSX.read(data, {
                type: 'binary',
              });

              workbook.SheetNames.forEach(function (sheetName) {
                const XL_row_object = XLSX.utils.sheet_to_row_object_array(
                  workbook.Sheets[sheetName]
                );
                resolve(XL_row_object);
              });
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = function (ex) {
            reject(ex);
          };

          reader.readAsBinaryString(file);
        });
      };

      const parseOriginal = function (original) {
        const data = original.map((d) => {
          const [datePart, timePart, _] = d[datetime].split(' ');
          const dateObj = parseDate(datePart + ' ' + timePart);
          return {
            date: formatDate(dateObj),
            dateObj: dateObj,
            time: formatTime(dateObj),
            timeObj: parseTime(timePart),
            value: +d[value].replace(',', '.'),
          };
        });
        // console.log(data);s
        drawChart(data);
      };

      d3.json('/data').then((original) => {
        original.shift(); // remove first element

        const data = original.map((d) => {
          const [datePart, timePart, _] = d.datetime.split(' ');
          const dateObj = parseDate(datePart + ' ' + timePart);
          return {
            date: formatDate(dateObj),
            dateObj: dateObj,
            time: formatTime(dateObj),
            timeObj: parseTime(timePart),
            value: +d.value.replace(',', '.'),
          };
        });
        drawChart(data);
      });

      let selectedDates = new Set();
      let timeRange = null;

      const drawChart = (originalData) => {
        const data = [...originalData]; // copy
        const uniqueDates = [...new Set(data.map((d) => d.date))].sort();
        const colorScale = d3
          .scaleOrdinal(d3.schemeCategory10)
          .domain(uniqueDates);

        // Initially select all dates
        selectedDates = new Set(uniqueDates);

        const filterData = () => {
          return data.filter(
            (d) =>
              selectedDates.has(d.date) &&
              (!timeRange ||
                (d.timeObj >= timeRange[0] && d.timeObj <= timeRange[1]))
          );
        };

        const updateCharts = () => {
          const filteredData = filterData();
          drawDateFilter(uniqueDates);
          drawTimeBrush(filteredData);
          drawMainChart(filteredData);
        };

        const drawDateFilter = (dates) => {
          const container = d3.select('#date-filter');
          container.selectAll('*').remove();

          const items = container
            .selectAll('.date-item')
            .data(dates)
            .enter()
            .append('div')
            .attr('class', 'date-item')
            .style('cursor', 'pointer')
            .style('padding', '5px')
            .style('background-color', (d) =>
              selectedDates.has(d) ? colorScale(d) : '#f0f0f0'
            )
            .style('color', (d) => (selectedDates.has(d) ? 'white' : 'black'))
            .style('margin-bottom', '2px')
            .style('font-size', '12px')
            .text((d) => formatDateLabel(parseDateLabel(d)))
            .on('click', function (event, d) {
              if (selectedDates.has(d)) {
                selectedDates.delete(d);
              } else {
                selectedDates.add(d);
              }
              updateCharts();
            });
        };

        const drawTimeBrush = (filteredData) => {
          const container = d3.select('#time-brush');
          container.selectAll('*').remove();

          if (!filteredData.length) {
            container
              .append('div')
              .attr('class', 'time-brush-empty')
              .text('No readings available for the current selection.');
            return;
          }

          const containerNode = container.node();
          const containerRect = containerNode
            ? containerNode.getBoundingClientRect()
            : { width: 952, height: 150 };

          const margin = { top: 24, right: 12, bottom: 32, left: 12 };
          const width = Math.max(
            200,
            containerRect.width - margin.left - margin.right
          );
          const height = Math.max(
            60,
            containerRect.height - margin.top - margin.bottom
          );

          const svg = container
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom + 20)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

          const [dayStart, dayEnd] = getDefaultTimeRange();
          const x = d3.scaleTime().domain([dayStart, dayEnd]).range([0, width]);

          const maxValue =
            d3.max(filteredData, (d) => d.value) ||
            d3.max(data, (d) => d.value);
          const y = d3
            .scaleLinear()
            .domain([0, Math.max(maxValue * 1.1, 1)])
            .range([height, 0]);

          const binInterval = d3.timeMinute.every(minuteStep);
          const densityData = [];

          if (binInterval) {
            const bins = binInterval.range(
              dayStart,
              d3.timeMinute.offset(dayEnd, minuteStep)
            );

            bins.forEach((start) => {
              const end = d3.timeMinute.offset(start, minuteStep);
              const bucket = filteredData.filter(
                (d) => d.timeObj >= start && d.timeObj < end
              );
              densityData.push({
                time: d3.timeMinute.offset(start, minuteStep / 2),
                value: bucket.length ? d3.mean(bucket, (d) => d.value) : null,
              });
            });
          }

          const gradientId = `time-density-gradient-${Date.now()}`;
          const defs = svg.append('defs');
          const gradient = defs
            .append('linearGradient')
            .attr('id', gradientId)
            .attr('x1', '0%')
            .attr('x2', '0%')
            .attr('y1', '0%')
            .attr('y2', '100%');

          gradient
            .append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#4f8ef7')
            .attr('stop-opacity', 0.65);
          gradient
            .append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#4f8ef7')
            .attr('stop-opacity', 0.05);

          const area = d3
            .area()
            .defined((d) => d.value !== null)
            .x((d) => x(d.time))
            .y0(height)
            .y1((d) => y(d.value))
            .curve(d3.curveMonotoneX);

          svg
            .append('path')
            .datum(densityData)
            .attr('class', 'time-density')
            .attr('fill', `url(#${gradientId})`)
            .attr('stroke', '#1f77b4')
            .attr('stroke-width', 1.5)
            .attr('d', area);

          svg
            .append('g')
            .attr('transform', `translate(0,${height})`)
            .call(
              d3
                .axisBottom(x)
                .ticks(d3.timeHour.every(2))
                .tickFormat(formatTime)
            );

          const selectionOverlay = svg
            .append('rect')
            .attr('class', 'time-selection-overlay')
            .attr('y', 0)
            .attr('height', height)
            .attr('rx', 4)
            .attr('ry', 4)
            .style('pointer-events', 'none');

          const brush = d3
            .brushX()
            .extent([
              [0, 0],
              [width, height],
            ])
            .on('brush', brushed)
            .on('end', brushEnded);

          const brushGroup = svg.append('g').attr('class', 'brush').call(brush);

          // Add time range display
          const timeRangeText = svg
            .append('text')
            .attr('class', 'time-range-text')
            .attr('x', 0)
            .attr('y', height + 45)
            .attr('font-size', '12px')
            .attr('fill', '#333');

          const resetButton = svg
            .append('text')
            .attr('class', 'brush-reset')
            .attr('x', width)
            .attr('y', -8)
            .attr('text-anchor', 'end')
            .text('Reset selection')
            .style('cursor', 'pointer')
            .style('fill', '#1f77b4')
            .on('click', () => {
              timeRange = null;
              updateCharts();
            });

          const updateSelectionOverlay = () => {
            const [start, end] = timeRange || getDefaultTimeRange();
            selectionOverlay
              .attr('x', x(start))
              .attr('width', Math.max(1, x(end) - x(start)))
              .style('opacity', timeRange ? 0.35 : 0.15);
          };

          const updateTimeRangeDisplay = () => {
            const [start, end] = timeRange || getDefaultTimeRange();
            const durationMinutes = Math.max(
              0,
              Math.round((end - start) / (60 * 1000))
            );
            const hours = Math.floor(durationMinutes / 60);
            const minutes = durationMinutes % 60;
            const durationLabel =
              durationMinutes >= 60
                ? `${hours}h ${minutes ? `${minutes}m` : ''}`.trim()
                : `${minutes}m`;

            const startTime = formatTime(start);
            const endTime = formatTime(end);
            const suffix = timeRange ? '' : ' (all day)';
            timeRangeText.text(
              `Time Range: ${startTime} – ${endTime}${suffix} • ${durationLabel}`
            );
          };

          function brushed(event) {
            if (!event.selection || !event.sourceEvent) {
              return;
            }
            const [startPx, endPx] = event.selection;
            let snappedStart = snapInterval.floor(x.invert(startPx));
            let snappedEnd = snapInterval.ceil(x.invert(endPx));

            if (snappedEnd <= snappedStart) {
              snappedEnd = snapInterval.offset(snappedStart, 1);
            }

            timeRange = [snappedStart, snappedEnd];
            updateSelectionOverlay();
            updateTimeRangeDisplay();

            brushGroup.call(brush.move, [x(snappedStart), x(snappedEnd)]);
          }

          function brushEnded(event) {
            if (!event.sourceEvent) {
              return;
            }
            if (!event.selection) {
              timeRange = null;
              updateSelectionOverlay();
              updateTimeRangeDisplay();
              updateCharts();
              return;
            }
            updateCharts();
          }

          updateSelectionOverlay();
          updateTimeRangeDisplay();

          const initialRange = timeRange ? timeRange : getDefaultTimeRange();
          brushGroup.call(brush.move, initialRange.map(x));
        };

        const drawMainChart = (filteredData) => {
          const container = d3.select('#main-chart');
          const containerNode = container.node();
          const filterNode = document.getElementById('date-filter');
          const fallbackRect = { width: 900, height: 520 };
          const containerRect = containerNode
            ? containerNode.getBoundingClientRect()
            : fallbackRect;
          const filterRect = filterNode
            ? filterNode.getBoundingClientRect()
            : fallbackRect;

          container.selectAll('*').remove();

          const margin = { top: 16, right: 60, bottom: 40, left: 60 };
          const width = Math.max(
            200,
            containerRect.width - margin.left - margin.right
          );
          const desiredHeight = filterRect.height || fallbackRect.height;
          const height = Math.max(
            220,
            desiredHeight - margin.top - margin.bottom
          );

          const svg = container
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

          const x = d3
            .scaleTime()
            .domain(timeRange || d3.extent(filteredData, (d) => d.timeObj))
            .range([0, width]);

          const y = d3
            .scaleLinear()
            .domain(d3.extent(filteredData, (d) => d.value))
            .nice()
            .range([height, 0]);

          // Group data by date
          const dateData = d3.group(filteredData, (d) => d.date);

          const line = d3
            .line()
            .x((d) => x(d.timeObj))
            .y((d) => y(d.value))
            .curve(d3.curveMonotoneX);

          svg
            .selectAll('.line')
            .data(
              Array.from(dateData, ([date, values]) => ({
                date,
                values: values.sort((a, b) => a.timeObj - b.timeObj),
              }))
            )
            .enter()
            .append('path')
            .attr('class', 'line')
            .attr('d', (d) => line(d.values))
            .attr('stroke', (d) => colorScale(d.date))
            .attr('stroke-width', 2)
            .attr('fill', 'none');

          svg
            .append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x));

          svg.append('g').call(d3.axisLeft(y));

          // Grid lines
          svg
            .append('g')
            .attr('class', 'grid')
            .attr('opacity', 0.3)
            .call(d3.axisBottom(x).tickSize(height).tickFormat(''));

          svg
            .append('g')
            .attr('class', 'grid')
            .attr('opacity', 0.3)
            .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));

          // Add click label background
          const clickLabelBg = svg
            .append('rect')
            .attr('class', 'click-label-bg')
            .style('fill', '#333')
            .style('visibility', 'hidden')
            .style('pointer-events', 'none');

          // Add click label
          const clickLabel = svg
            .append('text')
            .attr('class', 'click-label')
            .attr('x', 10)
            .attr('y', 20)
            .attr('font-size', '12px')
            // .attr('fill', '#fff')
            .style('pointer-events', 'none')
            .text('');

          // Add invisible overlay for click detection
          svg
            .append('rect')
            .attr('class', 'click-overlay')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', width)
            .attr('height', height)
            .style('fill', 'none')
            .style('pointer-events', 'all')
            .on('click', function (event) {
              const [mouseX, mouseY] = d3.pointer(event);
              const timeClicked = x.invert(mouseX);
              const valueClicked = y.invert(mouseY);

              // Find closest data point
              let closestPoint = null;
              let minDistance = Infinity;

              for (const [date, values] of dateData) {
                for (const point of values) {
                  const distance = Math.sqrt(
                    Math.pow(x(point.timeObj) - mouseX, 2) +
                      Math.pow(y(point.value) - mouseY, 2)
                  );
                  if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = point;
                  }
                }
              }

              if (closestPoint && minDistance < 50) {
                // Only show if close enough
                clickLabel
                  .attr('x', x(closestPoint.timeObj) + 5)
                  .attr('y', y(closestPoint.value) - 5)
                  .text(
                    `${formatTime(closestPoint.timeObj)}: ${closestPoint.value} mmol/L`
                  )
                  .attr('fill', 'white')
                  .style('visibility', 'visible');
                const bbox = clickLabel.node().getBBox();
                clickLabelBg
                  .attr('x', bbox.x - 2)
                  .attr('y', bbox.y - 2)
                  .attr('width', bbox.width + 4)
                  .attr('height', bbox.height + 4)
                  .style('visibility', 'visible');
              } else {
                clickLabel.style('visibility', 'hidden');
                clickLabelBg.style('visibility', 'hidden');
              }
            });
        };

        updateCharts();
      };
    </script>
  </body>
</html>
