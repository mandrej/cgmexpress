<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SIBIONICS CGM</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/crossfilter2@1.5.4/crossfilter.min.js"></script>
    <script src="https://unpkg.com/dc@4.2.7/dist/dc.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/jszip.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/xlsx.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/dc@4.2.7/dist/style/dc.min.css"
    />
    <link rel="stylesheet" href="style.css"/>

  </head>
  <body>
    <h3 style="margin-left: 10px;">SIBIONICS CGM</h3>
    <div class="row"">
      <div id="date-filter"></div>
      <div id="main-chart"></div>
    </div>
    <div class="row"">
      <div id="drop-zone" style="width: 120px; height: 50px; margin-top: 10px; margin-left: 10px; background-color: #ccc; text-align: center; padding-top: 20px;">Drag and drop files here</div>
      <div id="time-brush"></div>
    </div>

    <script>
      const dropZone = document.getElementById('drop-zone');
      dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.stopPropagation();
      });


      dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        event.stopPropagation();
        // File handling logic will go here
        const files = event.dataTransfer.files;
        const file = files[0];

        console.log('Dropped file type:', file.type);
        parseExcel(file).then((original) => {
          parseOriginal(original);
        }).catch((error) => {
          console.error('Error parsing Excel:', error);
        });
      });

      const parseExcel = function(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              var data = e.target.result;
              var workbook = XLSX.read(data, {
                type: 'binary'
              });

              workbook.SheetNames.forEach(function(sheetName) {
                const XL_row_object = XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName]);
                resolve(XL_row_object);
              });
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = function(ex) {
            reject(ex);
          };

          reader.readAsBinaryString(file);
        });
      };

      const parseOriginal = function(original) {
        const datetime = 'Vreme';
        const value = 'OÄitavanje senzora(mmol/L)';
        const parseDate = d3.timeParse('%d-%m-%Y %H:%M');
        const parseTime = d3.timeParse('%H:%M');
        const formatDate = d3.timeFormat('%Y-%m-%d');
        const formatTime = d3.timeFormat('%H:%M');

        const data = original.map((d) => {
          const [datePart, timePart, _] = d[datetime].split(' ');
          const dateObj = parseDate(datePart + ' ' + timePart);
          return {
            date: formatDate(dateObj),
            dateObj: dateObj,
            time: formatTime(dateObj),
            timeObj: parseTime(timePart),
            value: +d[value].replace(',', '.'),
          };
        });
        // console.log(data);s
        drawChart(data);
      }

      d3.json('/data').then((original) => {
        // --- Parse date/time, value ---
        const parseDate = d3.timeParse('%d-%m-%Y %H:%M');
        const parseTime = d3.timeParse('%H:%M');
        const formatDate = d3.timeFormat('%Y-%m-%d');
        const formatTime = d3.timeFormat('%H:%M');
        original.shift(); // remove first element

        const data = original.map((d) => {
          const [datePart, timePart, _] = d.datetime.split(' ');
          const dateObj = parseDate(datePart + ' ' + timePart);
          return {
            date: formatDate(dateObj),
            dateObj: dateObj,
            time: formatTime(dateObj),
            timeObj: parseTime(timePart),
            value: +d.value.replace(',', '.'),
          };
        });
        drawChart(data);
      });

      const drawChart = (data) => {
        const parseDate = d3.timeParse('%Y-%m-%d');
        const formatDate = d3.timeFormat('%a, %b %d, %Y');
        // Define color scale for consistent colors
        const uniqueDates = [...new Set(data.map((d) => d.date))];
        const colorScale = d3
          .scaleOrdinal(d3.schemeCategory10)
          .domain(uniqueDates);

        const ndx = crossfilter(data);

        // --- Define date filter chart ---
        const dateDim = ndx.dimension((d) => d.date);
        const dateGroup = dateDim.group();

        const dateFilter = new dc.RowChart('#date-filter');
        dateFilter
          .width(130)
          .height(400)
          .margins({ top: 20, left: 10, right: 0, bottom: 30 })
          .dimension(dateDim)
          .group(dateGroup)
          .label((d) => formatDate(parseDate(d.key))) // american style
          .ordering((d) => d.key)
          .colors(colorScale)
          .elasticX(true)
          .xAxis()
          .ticks(4);

        // --- Define time brush chart ---
        const timeBrush = new dc.BarChart('#time-brush');
        const timeDim = ndx.dimension((d) => d.timeObj);
        const timeGroup = timeDim.group();

        timeBrush
          .width(800)
          .height(100)
          .margins({ top: 10, right: 50, bottom: 20, left: 30 })
          .dimension(timeDim)
          .group(timeGroup)
          .x(
            d3
              .scaleTime()
              .domain([
                d3.min(data, (d) => d.timeObj),
                d3.max(data, (d) => d.timeObj),
              ])
          )
          .xUnits(d3.timeHour)
          .brushOn(true)
          .elasticY(true)
          .xAxis()
          .ticks(d3.timeHour.every(1));

        // --- Define main chart ---
        const seriesDim = ndx.dimension((d) => [d.date, d.timeObj]);
        const valueGroup = seriesDim.group().reduceSum((d) => d.value);

        const mainChart = new dc.SeriesChart('#main-chart');
        const minTime = d3.min(data, (d) => d.timeObj);
        const maxTime = d3.max(data, (d) => d.timeObj);

        mainChart
          .width(800)
          .height(400)
          .chart(
            (subChart) =>
              new dc.LineChart(subChart)
                .curve(d3.curveMonotoneX)
                .renderArea(false) // now applied correctly to each child line chart
          )
          .x(d3.scaleTime().domain([minTime, maxTime]))
          .y(
            d3
              .scaleLinear()
              .domain([
                d3.min(data, (d) => d.value),
                d3.max(data, (d) => d.value),
              ])
          )
          .elasticY(true)
          .renderHorizontalGridLines(true)
          .renderVerticalGridLines(true)
          .dimension(seriesDim)
          .group(valueGroup)
          .seriesAccessor((d) => d.key[0]) // each date = series
          .keyAccessor((d) => d.key[1]) // time = x
          .valueAccessor((d) => d.value) // value = y
          .colors(colorScale);
        // .legend(dc.legend().x(70).y(10).itemHeight(13).gap(5));

        // Update main chart domain based on time brush selection
        timeBrush.on('filtered', function (chart, filter) {
          if (filter) {
            mainChart.x().domain(filter);
          } else {
            mainChart.x().domain([minTime, maxTime]);
          }
          dc.redrawAll();
        });

        dc.renderAll();
      };
    </script>
  </body>
</html>
